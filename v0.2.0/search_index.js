var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ArtifactUtils","category":"page"},{"location":"#ArtifactUtils","page":"Home","title":"ArtifactUtils","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"add_artifact!\nartifact_from_directory\nupload_to_gist","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ArtifactUtils]","category":"page"},{"location":"#ArtifactUtils.add_artifact!-Tuple{String, String, String}","page":"Home","title":"ArtifactUtils.add_artifact!","text":"function add_artifact!(\n    artifacts_toml::String, name::String, tarball_url::String;\n    clear=true,\n    platform::Union{Platform,Nothing}=nothing,\n    lazy::Bool=false,\n    force::Bool=false\n)\n\nDownloads tarball from tarball_url, extracts it and adds it as an artifact with name name to the file artifacts_toml. If clear is true, the artifact itself is deleted afterwards. The rest of the keyword arguments are passed to Pkg.Artifacts.bind_artifact!.\n\nFrom its docstring:\n\nIf platform is not nothing, this artifact is marked as platform-specific, and will be a multi-mapping.  It is valid to bind multiple artifacts with the same name, but different platforms and hash'es within the same artifacts_toml.  If force is set to true, this will overwrite a pre-existant mapping, otherwise an error is raised.[...] If lazy is set to true, even if download information is available, this artifact will not be downloaded until it is accessed via the artifact\"name\" syntax, or ensure_artifact_installed() is called upon it.\n\n\n\n\n\n","category":"method"},{"location":"#ArtifactUtils.artifact_from_directory-Tuple{Any}","page":"Home","title":"ArtifactUtils.artifact_from_directory","text":"artifact_from_directory(source; follow_symlinks = false) -> artifact_id::SHA1\n\nCreate an artifact from the source directory and return the artifact_id.\n\n\n\n\n\n","category":"method"},{"location":"#ArtifactUtils.communicate-Tuple{Any, Any}","page":"Home","title":"ArtifactUtils.communicate","text":"communicate(cmd, input) -> output::Vector{UInt8}\n\nRun cmd, write input to its stdin, and return the bytes output read from its stdout. stderr is redirected to Base.stdout.\n\n\n\n\n\n","category":"method"},{"location":"#ArtifactUtils.copy_mode-Tuple{Any, Any}","page":"Home","title":"ArtifactUtils.copy_mode","text":"copy_mode(src, dst)\n\nCopy mode of src to dst recursively in a way compatible to how Pkg (Git) compute the tree hash.\n\nSee Pkg.GitTools.gitmode comment for how the file mode is handled specially in Windows: https://github.com/JuliaLang/Pkg.jl/blob/247a4062bfde19d93bdcbaccc9737df496fd0c2b/src/GitTools.jl#L189-L192\n\ncopy_mode is based on: https://github.com/JuliaIO/Tar.jl/blob/6a946029685639b69ce5a7cc4c4a6c0e6c6b2697/src/extract.jl#L145-L153\n\n\n\n\n\n","category":"method"},{"location":"#ArtifactUtils.gist_from_file-Tuple{AbstractString}","page":"Home","title":"ArtifactUtils.gist_from_file","text":"gist_from_file(filepath::AbstractString; private::Bool = true) -> fileurl::String\n\nCreate a new gist from file at filepath. Return the \"raw\" HTTPS URL of the file.\n\n\n\n\n\n","category":"method"},{"location":"#ArtifactUtils.git_empty_history-Tuple{Any}","page":"Home","title":"ArtifactUtils.git_empty_history","text":"git_empty_history(git_dir)\n\nEmpty the history of the current branch. Create an empty commit to start fresh.\n\n\n\n\n\n","category":"method"},{"location":"#ArtifactUtils.upload_to_gist","page":"Home","title":"ArtifactUtils.upload_to_gist","text":"upload_to_gist(\n    artifact_id::SHA1,\n    [tarball];\n    private::Bool = true,\n    honor_overrides = false,\n    # Following options are aviailable only when `tarball` is not specified:\n    name::AbstractString = \"$artifact_id.tar.gz\",\n    extension::AbstractString = \".tar.gz\",\n) -> gist\n\nCreate an artifact archive at path tarball (or in a temporary location) and upload it to gist. The returned value gist can be passed to add_artifact!.\n\nExtended help\n\nExamples\n\nusing ArtifactUtils\nadd_artifact!(\"Artifact.toml\", \"name\", upload_to_gist(artifact_from_directory(\"source\")))\n\ncreates an artifact from files in the \"source\" directory, upload it to gist, and then add it to \"Artifact.toml\" with the name \"name\".\n\nKeyword Arguments\n\nprivate: if true, upload the archive to a private gist\nname: name of the archive file, including file extension\nextension: file extension of the tarball. It can be used for specifying the compression method.\nhonor_overrides: see Pkg.Artifacts.archive_artifact\n\n\n\n\n\n","category":"function"},{"location":"#ArtifactUtils.with_new_gist-Tuple{Any}","page":"Home","title":"ArtifactUtils.with_new_gist","text":"with_new_gist(f; private::Bool = true) -> repo_http::AbstractString\n\nCreate a new gist, check it out as a local git repository at a temporary directory git_dir, call f(git_dir), and then push it to remote.  Return the canonical gist HTTPS URL.\n\n\n\n\n\n","category":"method"}]
}
